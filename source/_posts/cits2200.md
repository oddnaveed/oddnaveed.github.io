---
title: cits2200
date: 2020-06-03 01:07:44
tags: [dataStructure, algorithm, CITS2200]
categories: [software]
top:
visible:
---

## quick sort
- Given an unsorted array, we choose the last element as pivot value, and we need to place the pivot correctly in the array. This means all smaller elements are placed on the left hand side of the pivot, and all greater elements are placed on the right hand side. Then we quicksort left partition and right partition recursively untill all elements have been placed correctly.

<!--more-->

**Worst Case**: The worst case occurs when the partition process always picks greatest or smallest element as pivot. If we consider above partition strategy where last element is always picked as pivot, the worst case would occur when the array is already sorted in increasing or decreasing order. Following is recurrence for worst case.

```
T(n) = T(0) + T(n-1) + O(n)
which is equivalent to
T(n) = T(n-1) + O(n)
T(n) = T(0) + n*O(n)
The solution of above recurrence is O(n^2).
```

**Average Case**:
O(nlogn): when a pivot is picked, its values is averagely in the middle. Therefore, if each pivot picked is approximately in the middle, then the comparisons are HALVED due to the left side of the pivot, not needing to be compared to the right side of the pivot. This has to be done n for each number picked, and log n for not needing to compare half of it


```java
public void quickSort(long[] a, int p, int r){
    if(p<r){
        int q = partition(a, p, r);
        quickSort(a, p, q-1);
        quickSort(a, q+1, r);
    }
}

private int partition(long[] a, int p, int r){
    long pivot = a[r];
    int i = p-1;
    //from p to (r-1) --the index before pivot
    for(int j=p; j<=r-1; j++){
        if(a[j] <= pivot){
            i++;
            //swap a[i] and a[j]
            long temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
        count++;
    }
    // swap a[i+1] and a[r]
    long temp = a[i+1];
    a[i+1] = a[r];
    a[r] = temp;

    return i+1;
}
```

```java [practice]
private int partition(long[] a, int p, int r){
    long pivot = a[r];
    i = p-1;
    for(int j=p; j<r-1; j++){
        if(a[j]<=pivot){
            i++;
            //swap a[i] a[j]
            long temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
        count++;
    }
    // swap a[i+1] and a[r]
    long temp = a[i+1];
    a[i+1] = a[r];
    a[r] = temp;
    return i+1;
}

```


---

## insertion sort
- Given an unsorted array, we select an element as a key in the array from the second element to the last element, we compare the key with its previous elements one by one and swap the elements if the previous ones are bigger than the key value. Since the number of comparisons for each key is from 1 to n, and there are n keys in the array, the complexity of insertion sort is O(n^2).

```java
public void insertionSort(long[] a){
    int n = a.length;
    for(int j = 1; j<n; j++){
        long key = a[j];
        int i = j-1;

        while(i>0 && a[i]>key){
            a[i+1] = a[i];
            i = i-1;
        }
        a[i+1] = key;
    }
}
```


## merge sort

- Given an unsorted array, it is divided recursively into equally small arrays until it can no longer be divided. This takes O(logn) steps as the size of the array is reduced to half of its original size in each step. The next task is to merge these arrays progressively into larger and larger sorted arrays. In each step, there are two sorted arrays of length k, the task is to merge them into a sorted array of length 2k. This is done by walking simultaneously along the two arrays, comparing elements and inserting the elements at the correct positions in the array of length 2k. The complexity of merging is O(n) at each level. Since there are O(logn) levels, the overall complexity of merge sort is O(nlogn).

```java
public void mergeSort(long[] a){
    mergeSort(a, 0, a.length-1);
}

private void merge(long[] a, int p, int q, int r){
    int n = q-p+1; // the number of the elements of the left part
    int m = r-q;    // the number of the elements of the right part
    long[] an = new long[n];
    long[] am = new long[m];
    // we divide the array into two small arrays
    for(int i=0; i<n; i++){
        an[i] = a[p+i];
        count++;
    }
    for(int i=0; i<m; i++){
        am[i] = a[q+1+i];
        count++;
    }
    int i=0;
    int j=0;
    // merge the small arrays back into larger sorted array!!!!!!
    for(int k=p; k<=r; k++){
        if(i==n) a[k] = am[j++];
        else if(j==m || an[i]<am[j]) a[k] = an[i++];
        else a[k] = am[j++];
        count++;
    }
}

private void mergeSort(long[] a, int p, int r){
    if(p<r){
        int q = (p+r)/2;
        mergeSort(a,p,q);
        mergeSort(a,q+1,r);
        merge(a,p,q,r);
    }
}
```


## Big O notation

- f(n) is O(g(n)) if there is a constant c>0 and n0>=1 such that, for all n>=n0, f(n) <= cg(n).
- prove log^2n is O(n^2): we need to prove log^2n <= cn^2
- prove n^3logn is not O(n^2): if n^3logn is O(n^2), n^3logn <= cn^2, nlogn<=c, this is not true as the left hand side grows as n grows, while the right hand side is a constant.

## Kruskal's algorithm

- (ElogE)
- Kruskal's minimum spanning tree algorithm maintains a forest. It adds an edge of minimum weight from the remaining edges that has not yet been added to the forest until it gets spanning. A forest is a collection of trees.
- _this_ In Kruskal's algorithm, first, we choose the minimum weight edge from the remaining edges that have not yet been added to the forest. This can be done by sorting the E edges in ascending order by using an optimal sorting algorithm in O(ElogE) time. Second, we check if it remains a forest and no cycles are introduce. This is done by checking whether the two vertices of an edge are in different partitions. This is done through maintaining a disjoint sets forest. The complexity of this lookup is O(ElogV), as there are E edges and each lookup takes O(logV) time.

## Dijkstra's algorithm
- O(ElogV)
- single-source shortest paths algorithm
- A heap is built by inserting all the vertices with priority of infinity except the priority of source vertex as 0. The algorithm starts by dequeuing the vertex at the root of the heap, as s has the minimum priority, it will be dequeued first. Then the priorities of all the vertices adjacent to s are relaxed. Relaxation is to repalce the current priority with the shortest path from the source vertex. As a result, the vertices adjacent to s will have priority less than infinity and one of them will be at the root after the heapify operation. When a vertex is selected at the root of the heap, all its adjacent vertices are relaxed. The algorithm has a complexity O(ElogV) as each edge is selected once and the heapify operation due to relaxation takes O(logV) time for each vertex.

## Floyd-Warshall all-pairs shortest path algorithm
O(V^3)
- if d[ij] is the shortest path between a pair of vertices i and j, in this algorithm we compute the shortest path between i and j that goes through a set of vertices{1...k}. A new vertex is included in this set in each iteration and in the end all vertices are included, so that we get the actual shortest paths when the algorithm terminates. The algorithm starts with the matrix d[ij][0], which does not go through any other vertices and is the adjacency matrix with weights of edges. When the k+1 vertex is included, we check whether the new shortest path passing through vertex k+1 between i and j improves the previously stored shortest path and update if necessary. We potentially update a matrix of size V^2 when we include a new vertex, and there are V vertices, the complexity is O(V^3).

## Dynamic programming framework

- the problem is broken down into a collection of **smaller subproblems**
- the solution is built up from the **stored values of the solutions** to all of the subproblems.

## Prim's algorithm
- O(ElogV)
- from tree to spanning
- initialize the minimum spanning tree with a vertex chosen at random
- find all the edges connected to the current tree and add them into a priority queue
- dequeue the priority queue we get the minimum weight edge connected to the tree. Dequeue is a constant time operation.
- repeating above steps until the tree gets spanning.
- O(VlogV + ElogV) = O(ElogV)

If adjacency list is used to represent the graph, then using breadth first search, all the vertices can be traversed in O(V + E) time.
We traverse all the vertices of graph using breadth first search and use a min heap for storing the vertices not yet included in the MST.
To get the minimum weight edge, we use min heap as a priority queue.
Min heap operations like extracting minimum element and decreasing key value takes O(logV) time.
 

So, overall time complexity

= O(E + V) x O(logV)

= O((E + V)logV)

= O(ElogV)

---


## Bellman-Ford algorithm

- negative edge weights
- E(V-1) + E = O(EV)
- Check E edges for a total V-1 times, then check if it contains negative weight cycle (E)
- dynamic programming
- [Geeksforgeeks](https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/)
- [MIT Open Course](https://www.youtube.com/watch?v=Ttezuzs39nk)
- "It first calculates the shortest distances with at most one edge in the path. Then it calculates the shortest paths with at-most 2 edges, and so on. After the i-th iteration of the outer loop, the shortest paths with at most i edges are calculated. There can be maximum V-1 edges in any simple path, so the relaxation runs V-1 times, we iterate through e edges each time, in total it takes O(E(V-1)). Then we use a failure check loop to check if we can relax it. If we can still relax it then there exists negative weight cycle. Since there are E edges this loop takes O(E)."

## a list of stacks

```java [baisc recursive stack]
public class LinkedStack{
    private Link first;

    public LinkedStack(){
        first = null;
    }

    public boolean isEmpty(){
        return first == null;
    }

    public void insert(Object o){
        first = new Link(o, first);
    }

    public Object examine() throws Exception{
        if(!isEmpty()){
            return first.item;
        } else throw new Exception("empty list");
    }

    public void delete() throws Underflow{
        if(!isEmpty()){
            first = first.successor;
        } else throw new Underflow("empty list");
    }
}
```

```java
import CITS2200.*;

public class ListLinked implements CITS2200.List{
    private Link before;
    private Link after;

    public ListLinked(){
        after = new Link(null, null);
        before = new Link(null, after);
    }

    private class Link{
        private Object item;
        private Link successor;

        public Link(Object e, Link s){
            item = e;
            successor = s;
        }
    }

    private class WindowLinked{
        private Link link;

        public WindowLinked(){
            link = new Link(null, null);
        }
    }


    public boolean isEmpty(){
        return before.successor == after;
    }

    public boolean isBeforeFirst(WindowLinked w){
        return w.link == before;
    }

    public boolean isAfterLast(WindowLinked w){
        return w.link == after;
    }

    /**
     *
     * @param w
     * @return
     * @throws OutOfBounds if w is over the before first or after last postiion,
     * otherwise deletes and returns the element under w, and places w over the next element
     */
    public Object delete(WindowLinked w) throws OutOfBounds{
        if(isBeforeFirst(w) || isAfterLast(w)){
            throw new OutOfBounds("cannot delete at this point");
        }
        Object item = w.link.item;
        Link next = w.link.successor;
        w.link.item = next.item;
        w.link.successor = next.successor;
        if(next == after){
            after = w.link;
        }
        return item;
    }

    /**
     * throws an exeption if w is over the before first or after last position,
     * otherwise repalces the element under w with e and returns the old element
     */
    public Object replace(Object e, WindowLinked w) throws OutOfBounds{
        if(isBeforeFirst(w) || isAfterLast(w))
            throw new OutOfBound("cannot replace at this point");
        Object item = w.link.item;
        w.link.item = e;
        return item;
    }

    public Object examine(WindowLinked w) throws OutOfBounds{
        if(isBeforeFirst(w) || isAfterLast(w))
            throw new OutOfBounds("cannot retrieve data here");
        return w.link.item;
    }

    /**
     *
     * @param e
     * @param w
     * @throws OutOfBound if w is over the before first position
     * otherwise insert an element before w
     */
    public void insertBefore(Object e, WindowLinked w) throws OutOfBound{
        if(isBeforeFirst(w))
            throw new OutOfBound("cannot insert before this point");
        w.link.successor = new Link(w.link.item, w.link.successor);
        if(isAfterLast(w))
            after = w.link.successor;
        w.link.item = e;
        w.link = w.link.successor; // move the window pointer back to original place
    }

    /**
     * throws OutOfBound if w is over after last position
     * otherwise insert an element after w
     */
    public void insertAfter(Object e, WindowLinked w) throws OutOfBound{
        if(isAfterLast(w))
            throw new OutOfBound("cannot insert after this point");
        w.link.successor = new Link(e, w.link.successor);
    }

    /**
     *
     * @param w
     * @throws OutOfBounds if w is over before first position,
     * otherwise move w to the previous window position
     */
    public void previous(WindowLinked w) throws OutOfBounds{
        if(isBeforeFirst(w))
            throw new OutOfBound("w is the start of the list");
        Link cursor = before;
        while(cursor.successor != w.link){
            cursor = cursor.successor;
        }
        w.link = cursor;
    }

    /**
     * @throws OutOfBounds if w is over after last position
     * otherwise move w to the next window posiiton
     */
    public void next(WindowLinked w) throws OutOfBounds{
        if(isAfterLast(w))
            throw new OutOfBound("w is the end of the list");
        w.link = w.link.successor;
    }

    /**
     * initialises w to the after last position
     */
    public void afterLast(WindowLinked w){
        w.link = after;
    }

    /**
     * initialises w to the before first position
     * @param w
     */
    public void beforeFirst(WindowLinkded w){
        w.link = before;
    }

    public String toString(){
        String a = "";
        Link cursor = before;
        while(cursor != null){
            a += cursor.item + ",";
            cursor = cursor.successor;
        }
        return a;
    }
}
```

## Stack Block

```java
import CITS2200.Overflow;
import CITS2200.Stack;
import CITS2200.Underflow;

public class StackBlock implements Stack{
	private int s;
	private Object[] stack;
	private int top;


	public StackBlock(final int s) {
		if (s < 1) {
			throw new IllegalArgumentException("Max Elements cannot be less than 1, was: " + s);
		}
		this.s = s;
		stack = new Object[s];
		top = 0;
	}


	public boolean isEmpty() {
		return (top == 0);
	}

	public boolean isFull() {
		return (top >= stack.length);
	}


	public void push(Object o) throws Overflow {
		if (isFull()) {
			throw new Overflow("the stack is full");
		}
		stack[top] = o;
		top++;

	}

	public Object examine() throws Underflow {
		if (isEmpty()) {
			throw new Underflow("the stack is empty");
		}
		else {
			return stack[top-1];
		}
	}


	public Object pop() throws Underflow {
		if (!isEmpty()) {
			top--;
			return (stack[top]);
		}
		else throw new Underflow("the stack is empty");
	}
}
```

## DequeCyclic (queue)

```java
import CITS2200.Deque;
import CITS2200.Overflow;
import CITS2200.Underflow;

public class DequeCyclic implements Deque {
    private int left, right, size, capacity;
    private Object[] queue;

    public DequeCyclic(final int s){
        left = right = size = 0;
        queue = new Object[s];
        capacity = s;
    }

    public boolean isEmpty(){
        return (size == 0);
    }

    public boolean isFull(){
        return (size == capacity);
    }

    public void pushLeft(Object c) throws Overflow{
        if(isFull()){
            throw new Overflow("the queue is full");
        }
        else if(left == 0 && right == 0 && size == 0){
            queue[0] = c;  // empty queue
        }else{
            left = (left + 1) % queue.length;
            queue[left] = c;
        }
        size++;
    }

    public void pushRight(Object c) throws Overflow{
        if (isFull()) {
            throw new Overflow("the queue is full");
        }
        else if(left == 0 && right == 0 && size == 0){
            queue[0] = c;  //empty queue
        }
        else {
            right = (right+queue.length-1) % queue.length;
            queue[right] = c;
        }
        size++;
    }

    public Object peekLeft() throws Underflow{
        if(isEmpty()){
            throw new Underflow("the queue is empty");
        }
        return queue[left];
    }

    public Object peekRight() throws Underflow{
        if(isEmpty()){
            throw new Underflow("the queue is empty");
        }
        return queue[right];
    }

    public Object popLeft() throws Underflow{
        if(isEmpty()){
            throw new Underflow("the queue is empty");
        }
        Object temp;
        temp = queue[left];
        queue[left] = null;
        left = (left+queue.length-1) % queue.length;
        size--;
        return temp;
    }

    public Object popRight() throws Underflow{
        if(isEmpty()){
            throw new Underflow("the queue is empty");
        }
        Object temp;
        temp = queue[right];
        queue[right] = null;
        right = (right+1) % queue.length;
        size--;
        return temp;
    }
}
```


## Empirical measurement

- run the system with real-world input and observe, or monitor the results

`Advantages`

- nondestructive
- cheap
- fast
- reproducible

`Disadvantages`
- only as good as the simulations
- can never be sure it matches reality

## Analytical Measurement
`Advantages`
- independent of run-time environment, less susceptible to the speed of hardware, number of other processes running etc, choice of data sets
- helps in understanding data structures and their implementations

`Disadvantages`
- coarse estimates
- growth rates, complexity classes rather than actual time
- worst case or average case


## Amortized Case Analysis
- a variety of worst case analysis
- examines the cost of repeating the operation in a sequence
- the cost of an expensive operation is amortized over the cheaper ones which must accompany it

`example`
A mountain climber can climb 10 kms in a day. She can descend 30 kms in a day. 
What is her amortized rate of travel?
(a) 10 kms per day
(b) 15 kms per day
(c) 20 kms per day
(d) 30 kms per day
<br />

For an amortized rate, you basically have to take into consideration **the rate of 
travel for the whole mountain climb together** (basically an average rate for the whole mountain climb rather considering each process seperately). 

So if we pick an arbitary value(any value will work really) and say that the mountain 
is 60km, we can see it will take 6 days to climb the mountain, and 2 days to descend. 
Overall it took 8 days for this mountain trip, in which we walked a total of 120km 
(60km up and down). The amortised rate would therefore be 120km travelled divided by 
the total of 8 days (15km/day)

answer:b

---

## Bintree

```java [cits2200 lab solution]
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Queue;
import CITS2200.BinaryTree;
import CITS2200.Iterator;

// complete an implementation of an abstract class of an immutable binary tree

public class BinTree extends BinaryTree<Object> {
    public BinTree() {
        super();
    }

    public BinTree(Object item, BinaryTree<Object> b1, BinaryTree<Object> b2) {
        super(item, b1, b2);
    }

    public boolean equals(Object o) {
        if ((this == null ^ o == null) || !(o instanceof BinaryTree)) {
            return false;

        }
        // casting
        BinaryTree<Object> t = (BinaryTree<Object>) o;
        if (this.isEmpty() ^ t.isEmpty()) {
            return false;
        }
        if (this.isEmpty() && t.isEmpty()) {
            return true;

        }

        return ((this.getItem().equals(t.getItem())) && (this.getLeft().equals(t.getLeft()))
                && (this.getRight().equals(t.getRight())));

    }

    public Iterator<Object> iterator() {
        return new BinaryTreeIterator(this);
    }

    class BinaryTreeIterator implements Iterator<Object> {
        private Queue<BinaryTree<Object>> q = new LinkedList<BinaryTree<Object>>();

        public BinaryTreeIterator(BinTree b) {
            if (b == null) {
                return;
            } else {
                q.add(b);
            }
        }

        public boolean hasNext() {
            return !q.isEmpty();
        }

        public Object next() {
            if (hasNext()) {
                BinTree b = (BinTree) q.remove();

                if (!b.getLeft().isEmpty()) {
                    q.add(b.getLeft());
                }

                if (!b.getRight().isEmpty()) {
                    q.add(b.getRight());
                }

                Object o = new Object();
                if (!b.isEmpty()) {
                    o = b.getItem();
                }
                return o;

            } else
                throw new NoSuchElementException("No more elements in the binary tree");
        }
    }
}
```

- external node: empty tree
- leaf: an internal node whose left and right subtrees are both empty(external nodes)
- the external nodes of a tree define its frontier
- skinny: each node has at most one child node
- complete: external nodes(and hence leaves) appear on at most two parent levels

- degree/valency: the number of vertices parent to v
- spanning: all vertices
- [induced subgraph](https://mathworld.wolfram.com/Vertex-InducedSubgraph.html)
- forest: a collection of trees
- orchard: a list(or queue) of trees

## Depth-first Traversal

- preorder: nlr
- postorder: lrn
- inorder: lnr

``` [Basic recursive depth-first search]
procedure DFS(w)
    colour[w] <- grey
    for each vertex x adjacent to w do
        if colour[x] is white then
            pi[x] <- w
            DFS(x)
        end if
    end for
    colour[w] <- black
```

``` [Non-recursive DFS]
procedure DFS(w)
    initialize stack S
    push w onto S
    while S not empty do
        x <- pop off S
        if colour[x]=white then
            colour[x] <- black
            for each vertex y adjacent to x do
                if colour[y] is white then
                    push y onto S
                    pi[y] <- x
                end if
            end for
        end if
    end while
```

```java 
public int[] getDistances(Graph g, int startVertex){
    int vNum = g.getNumberOfVertices();

    int distance[] = new int[vNum];
    for(int i=0; i<vNum; i++){
        distance[i] = -2;
    }

    int[][] matrix = g.getEdgeMatix();

    boolean checked[] = new boolean[vNum];

    Queue<Integer> q = new LinkedList<Integer>();

    queue.add(startVertex);
    checked[startVertex] = true;
    distance[startVertex] = 0;

    while(!q.isEmpty()){
        int currentVertex = q.poll();

        for(int i=0; i<vNum; i++){
            if(matrix[currentVertex][i] == 1 && checked[i] == false && !q.contains(i) && currentVertex!=i){
                distance[i] = distance[currentVertex] + 1;
                queue.add(i);
            }
        }
        checked[currentVertex] = true;
    }
    for(int i=0; i<vNum; i++){
        if(distance[i] == -2){
            distance[i] = -1;
        }
    }

    return distance;
}
```

``` [Discovery and finish times]
procedure DFS(w)
    colour[w] <- grey
    discovery[w] <- time
    time <- time+1
    for each vertex x adjacent to w do
        if colour[x] is white then
            pi[x] <- w
            DFS(x)
        end if
    end for
    colour[w] <- black
    finish[w] <- time
    time <- time+1
```


```java [Discovery and finish times]
public int[][] getTimes(Graph g, int startVertex){
    int vNum = g.getNumberOfVertices();
    int[][] times = new int[vNum][2];
    int time = 0;
    timeQueue = new LinkedList<Integer>();
    int[][] matrix = g.getEdgeMatrix();
    checked = new boolean[vNum];
    DFS(startVertex, vNum, matrix);
    return times;
}

private void DFS(int vertex, int vNum, int[][] matrix){
    timeQueue.add(vertex);

    times[vertex][0] = time;
    time++;
    for(int i=0; i<vNum; i++){
        if(matrix[vertex][i] == 1 && checked[i] == false && !timeQueue.contains(i) && vertex != i){
            timeQueue.add(i);
            DFS(i, vNum, matrix);
        }
        checked[vertex] = true;
        timeQueue.poll();
        times[vertex][1] = time;
        time++;
    }
}
```


## Level-order (Breadth-first) Traversal

```java [Algorithm]
place tree(root window) in empty queue q
while(!q.isEmpty()){
    dequeue first item;
    if(!external node){
        visit its root node;
        enqueue left subtree(root window);
        enqueue right subtree(root window);
    }
}
```

`Time analysis`
- O(V+E): During the breadth-first search, each vertex is enqueued once and dequeued once. Each enqueue and dequeue operation takes constant time, the queue manipulation takes O(V) time. At the time the vertex is dequeued, the adjacency list of that vertex is completely examined, therefore we take O(E) time examining all the adjacency lists and the total time is O(V+E).

```java
import java.util.LinkedList;
import java.util.Queue;

import CITS2200.Graph;
import CITS2200.Search;

public class SearchImp implements Search{
    int time;
    int times[][];
    Queue<Integer> timeQueue;
    boolean checked[];

    public int[] getConnectedTree(Graph g, int startVertex){
        int vNum = g.getNumberOfVertices();

        int parent[] = new int[vNum];
        for(int i=0; i<vNum; i++){
            parent[i] = -2;
        }

        int[][] matrix = g.getEdgeMatrix();

        checkd = new boolean[vNum];

        Queue<Integer> queue = new LinkedList<Integer>();

        queue.add(startVertex);
        checked[startVertex] = true;

        while(!queue.isEmpty()){
            int currentVertex = queue.poll();

            for(int i=0; i<vNum; i++){
                if(matrix[currentVertex][i] == 1 && checked[i] == false && !queue.contains(i) && !(currentVertex == i)){
                    parent[i] = currentVertex;
                    queue.add(i);
                }
            }
            checked[currentVertex] = true;
        }

        for(int i=0; i<vNum; i++){
            if(parent[i] == -2){
                parent[i] = -1;
            }
        }

        return parent;
    }
}
```

- Uses of BFS: determining whether a graph is connected, or finding the distance between two vertices

``` [BFS finding distances]
while Q is not empty
    pop vertex w from the head of the Q
    for each vertex x adjacent to w do
        if colour[x] is white then
            dist[x] <- dist[w]+1
            pi[x] <- w
            colour[x] <- grey
            push x on to the tail of Q
        end if
    end for
    colour[w] <- black
end while
```

```java [BFS finding distances]
int[] dist = new int[vNum];

while(!q.isEmpty()){
    int currentVertex = q.poll();
    for(int i; i<vNum; ++i){
        if(matrix[currentVertex][i] == 1 && !checked[i] && currentVertex != i && !q.contains(i)){
            dist[i] = dist[currentVertex] + 1;
            parent[i] = currentVertex;
            q.add(i);
        }
    }
    checked[currentVertex] = true;
}
```

## Topological sort
- classic simple application of depth-first search
- dag(directed acyclic graph): a directed graph with no directed cycles
- in a depth-first search of a dag there are no back edges
`Algorithm:`
- Apply the depth-first search procedure to find the finishing times of each vertex. When each vertex is finished, put it onto the front of a linked list. The linked list will contain the vertices in topologically sorted order.

`Time Analysis:`
- O(V+E): it takes O(V+E) time for the depth-first search, and it takes O(V) time for the manipulation of the linked list. So the total time taken is again O(V+E).


## Summary
- Searching may occur breadth first or depth first
- DFS and BFS create a spanning tree from any graph
- BFS visits the vertices nearest to the source first. It can be used to determine whether a graph is connected.
- DFS visits the vertices furthest to the source first. It can be used to perform a topological sort.

## binary search
- O(logn)

## heap sort
- heapify-O(logn): a balanced binary tree with n elements in it has a height of logn and hence heapify performs at most logn exchanges.
  
```java [Heapsort]
int[] heapSort(int arr){
    //create an empty priority queue
    PQueue pq = new PQueue();
    //add in the elements with themselves as the key
    for(int i : arr){
        pq.add(i,i);
    }
    //create an array to store the result
    int[] ans = new int[arr.length];
    //dequeue the elements from the priority queue into ans array
    for(int i=0; i<ans.length; i++){
        ans[i] = pq.dequeue();
    }
    return ans;
}
```

- enqueue O(logn): the key is entered at the end of the array(last position in the tree). If the new key is greater than its parent, we swap the two elements and keep examining parents. In the worst case, will do logn exchanges 
- examine O(1): returns the root of the binary tree which has the biggest value.
- dequeue O(logn): delete root node from the tree, move the final element in the tree to the root position and then call heapify(1) to restore the heap property. This takes a few constant time operations, together with one call to heapify -> O(logn)

---


## Heap

- Since a heap can be constructed in O(n) time, we first build a heap with the minimum element at the root. Then we deque k elements from the heap one by one. In each dequeue operation, we return the element at the root, move the final entry in the heap to the newly-vacated root position, then call heapify(1) to restore the heap property. Each dequeue operation takes O(logn) time. It runs dequeue for k times, so the total complexity is O(klogn) which is faster than O(nlogn).
  